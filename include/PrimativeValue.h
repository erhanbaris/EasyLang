#ifndef EASYLANG_PRIMATIVEVALUE_H
#define EASYLANG_PRIMATIVEVALUE_H

#include <string>
#include <unordered_map>
#include <vector>
#include <sstream>
#include <iostream>
#include <memory>
#include "Definitions.h"
#include "FunctionDispatch.h"

struct PrimativeValue {
    enum class Type {
        PRI_INTEGER,
        PRI_DOUBLE,
        PRI_STRING,
        PRI_BOOL,
        PRI_ARRAY,
        PRI_DICTIONARY,
        PRI_NULL
    };

    Type Type;

    union {
        int Integer;
        double Double;
        bool Bool;
        string_type* String;
        std::vector<PrimativeValue*>* Array;
        std::unordered_map<string_type, PrimativeValue*>* Dictionary;
    };

    PrimativeValue() { Integer = 0; Type = Type::PRI_NULL; }
    PrimativeValue(int value) { Integer = value; Type = Type::PRI_INTEGER; }
    PrimativeValue(double value) { Double = value; Type = Type::PRI_DOUBLE;}
    PrimativeValue(string_type const & value) { String = new string_type(value); Type = Type::PRI_STRING;}
    PrimativeValue(bool value) { Bool = value; Type = Type::PRI_BOOL;}
    PrimativeValue(std::vector<PrimativeValue*>* value) { Array = value; Type = Type::PRI_ARRAY;}
    PrimativeValue(std::unordered_map<string_type, PrimativeValue*>* value) { Dictionary = value; Type = Type::PRI_DICTIONARY;}


    static PrimativeValue* CreateArray()
    {
        return new PrimativeValue(new std::vector<PrimativeValue*>());
    }

    static PrimativeValue* CreateArray(size_t length)
    {
        return new PrimativeValue(new std::vector<PrimativeValue*>(length));
    }

    static PrimativeValue* CreateDictionary()
    {
        return new PrimativeValue(new std::unordered_map<string_type, PrimativeValue*>());
    }

    static PrimativeValue* CreateBool()
    {
        return new PrimativeValue(false);
    }

    static PrimativeValue* CreateBool(bool value)
    {
        return new PrimativeValue(value);
    }

    static PrimativeValue* CreateString(string_type const & value)
    {
        return new PrimativeValue(value);
    }

    static PrimativeValue* CreateString()
    {
        return new PrimativeValue(L"");
    }

    static PrimativeValue* CreateDouble(double value)
    {
        return new PrimativeValue(value);
    }

    static PrimativeValue* CreateDouble()
    {
        return new PrimativeValue(0.0);
    }

    static PrimativeValue* CreateInteger(int value)
    {
        return new PrimativeValue(value);
    }

    static PrimativeValue* CreateInteger()
    {
        return new PrimativeValue(0);
    }


    ~PrimativeValue() { 
        switch (Type)
        {
            case PrimativeValue::Type::PRI_STRING:
                delete String;
                break;

            case PrimativeValue::Type::PRI_ARRAY:
            {
                size_t totalArray = Array->size();
                for (size_t i = 0; i < totalArray; i++)
                    delete Array->at(i);

                delete Array;
            }
            break;

            case PrimativeValue::Type::PRI_DICTIONARY:
            {
                auto end = Dictionary->end();
                for (auto it = Dictionary->begin(); it != end; ++it)
                    delete it->second;

                delete Dictionary;
            }
            break;

        }
    }

    string_type Describe()
    {
        switch (Type)
        {
        case PrimativeValue::Type::PRI_BOOL:
            return Bool ? _T("(BOOL) true") : _T("(BOOL) false");
        case PrimativeValue::Type::PRI_DOUBLE:
            return _T("(DOUBLE) ") + AS_STRING(Double);
        case PrimativeValue::Type::PRI_INTEGER:
            return _T("(INTEGER) ") + AS_STRING(Integer);
        case PrimativeValue::Type::PRI_STRING:
            return _T("(STRING) ") + *String;
        case PrimativeValue::Type::PRI_ARRAY:
        {
            string_stream stream;
            stream << _T("(ARRAY) ");

            if (Array != nullptr && !Array->empty())
            {
                stream << _T("Size: ")
                       << Array->size()
                       << '\n';

                for (int i = 0; i < Array->size(); ++i) {
                    stream  << i << _T(". ")
                            << Array->at(i)->Describe()
                            << '\n';
                }
            }
            else
                stream << _T("Size: 0");

            return stream.str();
        }
        }

        return _T("(empty)");
    }
    
    operator string_type ()
    {
        switch (Type)
        {
            case PrimativeValue::Type::PRI_BOOL:
                return Bool ? _T("true") : _T("false");
            case PrimativeValue::Type::PRI_DOUBLE:
                return AS_STRING(Double);
            case PrimativeValue::Type::PRI_INTEGER:
                return AS_STRING(Integer);
            case PrimativeValue::Type::PRI_STRING:
                return *String;
            default:
                return _T("");
        }
    }

    PrimativeValue* Clone()
    {
        switch (Type)
        {
            case PrimativeValue::Type::PRI_BOOL:
                return new PrimativeValue(Bool);
            case PrimativeValue::Type::PRI_DOUBLE:
                return new PrimativeValue(Double);
            case PrimativeValue::Type::PRI_INTEGER:
                return new PrimativeValue(Integer);
            case PrimativeValue::Type::PRI_STRING:
                return new PrimativeValue(*String);
            case PrimativeValue::Type::PRI_ARRAY:
            {
                auto* returnValue = new PrimativeValue();
                returnValue->SetArray(new std::vector<PrimativeValue*>());

                if (Array != nullptr && !Array->empty())
                {
                    for (int i = 0; i < Array->size(); ++i) {
                        returnValue->Array->push_back(Array->at(i)->Clone());
                    }
                }

                return returnValue;
            }
        }

        return nullptr;
    }

    void SetInteger(int value) { Integer = value; Type = Type::PRI_INTEGER; }
    void SetDouble(double value) { Double = value; Type = Type::PRI_DOUBLE; }
    void SetString(string_type value)
    {
        String = new string_type(value);
        Type = Type::PRI_STRING;
    }
    void SetBool(bool value) { Bool = value; Type = Type::PRI_BOOL; }
    void SetArray(std::vector<PrimativeValue*>* value) { Array = value; Type = Type::PRI_ARRAY; }
    void SetDictionary(std::unordered_map<string_type, PrimativeValue*>* value) { Dictionary = value; Type = Type::PRI_DICTIONARY; }
    void SetNull() { Integer = 0; Type = Type::PRI_NULL; }

    bool IsInteger() { return Type == Type::PRI_INTEGER; }
    bool IsDouble() { return Type == Type::PRI_DOUBLE; }
    bool IsString() { return Type == Type::PRI_STRING; }
    bool IsBool() { return Type == Type::PRI_BOOL; }
    bool IsArray() { return Type == Type::PRI_ARRAY; }
    bool IsDictionary() { return Type == Type::PRI_DICTIONARY; }
    bool IsNull() { return Type == Type::PRI_NULL; }
    
    void Append(PrimativeValue * rhs)
    {
        switch (this->Type)
        {
            case PrimativeValue::Type::PRI_STRING:
            {
                switch (rhs->Type)
                {
                    case PrimativeValue::Type::PRI_INTEGER:
                        this->String = new string_type(*this->String + AS_STRING(rhs->Integer));
                        break;
                        
                    case PrimativeValue::Type::PRI_DOUBLE:
                        this->String = new string_type(*this->String + AS_STRING(rhs->Double));
                        break;
                        
                    case PrimativeValue::Type::PRI_STRING:
                        this->String = new string_type(*this->String + *rhs->String);
                        break;
                }
            }
                break;
                
            case PrimativeValue::Type::PRI_ARRAY:
                this->Array->push_back(rhs);
                break;
        }
    }

    Any* AsAny()
    {
        switch (this->Type)
        {
        case PrimativeValue::Type::PRI_BOOL:
            return new Any(this->Bool);
            break;

        case PrimativeValue::Type::PRI_DOUBLE:
            return new Any(this->Double);
            break;

        case PrimativeValue::Type::PRI_INTEGER:
            return new Any(this->Integer);
            break;

        case PrimativeValue::Type::PRI_STRING:
            return new Any(*this->String);
                break;
                
            case PrimativeValue::Type::PRI_ARRAY:
            {
                std::vector<Any> vec;
                size_t count = this->Array->size();
                for (size_t i = 0; i < count; ++i)
                    vec.push_back(this->Array->at(i)->AsAny());
                
                return new Any(vec);
            }
                break;
                
            case PrimativeValue::Type::PRI_DICTIONARY:
                return new Any(*this->Dictionary);
                break;
        }

        return new Any();
    }

    void FromAny(Any& any)
    {
        if (any.is<int>())
            this->SetInteger(any.cast<int>());
        else if (any.is<bool>())
            this->SetBool(any.cast<bool>());
        else if (any.is<string_type>())
            this->SetString(any.cast<string_type>());
        else if (any.is<double>())
            this->SetDouble(any.cast<double>());
    }

    PrimativeValue & operator=(const PrimativeValue &rhs)
    {
        switch (rhs.Type)
        {
            case PrimativeValue::Type::PRI_BOOL:
                SetBool(rhs.Bool);
                break;

            case PrimativeValue::Type::PRI_DOUBLE:
                SetDouble(rhs.Double);
                break;

            case PrimativeValue::Type::PRI_INTEGER:
                SetInteger(rhs.Integer);
                break;

            case PrimativeValue::Type::PRI_STRING:
                SetString(*rhs.String);
                break;
        }

        return *this;
    }

    PrimativeValue * operator=(const PrimativeValue *rhs)
    {
        if (rhs == nullptr)
            return nullptr;

        switch (rhs->Type)
        {
            case PrimativeValue::Type::PRI_BOOL:
                SetBool(rhs->Bool);
                break;

            case PrimativeValue::Type::PRI_DOUBLE:
                SetDouble(rhs->Double);
                break;

            case PrimativeValue::Type::PRI_INTEGER:
                SetInteger(rhs->Integer);
                break;

            case PrimativeValue::Type::PRI_STRING:
                SetString(*rhs->String);
                break;
        }

        return this;
    }
};

PrimativeValue* operator + (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator - (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator * (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator / (PrimativeValue const & lhs, PrimativeValue const & rhs);

PrimativeValue* operator > (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator >= (PrimativeValue const & lhs, PrimativeValue const & rhs);

PrimativeValue* operator < (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator <= (PrimativeValue const & lhs, PrimativeValue const & rhs);

PrimativeValue* operator != (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator == (PrimativeValue const & lhs, PrimativeValue const & rhs);

PrimativeValue* operator && (PrimativeValue const & lhs, PrimativeValue const & rhs);
PrimativeValue* operator || (PrimativeValue const & lhs, PrimativeValue const & rhs);

typedef std::shared_ptr<std::vector<PrimativeValue*> > FunctionArgs;

#endif //EASYLANG_PRIMATIVEVALUE_H
